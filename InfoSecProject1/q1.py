from Crypto.PublicKey import RSA
from Crypto.PublicKey import ECC
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import NoEncryption
from cryptography.hazmat.primitives.serialization import Encoding
from cryptography.hazmat.primitives.serialization import PrivateFormat, PublicFormat
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives.kdf.hkdf import HKDF

from color import *

# Generate keys using RSA
def generate_rsa():
    keyPair = RSA.generate(1024)
    pubKey = keyPair.publickey()

    return {
        "keyPair": keyPair,
        "public": {"n": pubKey.n, "e": pubKey.e},
        "private": {"n": pubKey.n, "d": keyPair.d}
    }

# Generate keys using Eliptic Curve Diffie-Hellman (ECDH)
def generate_ECDH():
    key1 = ec.generate_private_key(ec.SECP384R1())

    key2 = ec.generate_private_key(ec.SECP384R1())

    return key1, key2

# Print the keys generated by the ECDH algorithm
def printECDH(key):
    printColored("Public key:", key.public_key().public_bytes(format=PublicFormat.SubjectPublicKeyInfo,
                                                              encoding=Encoding.DER).hex())
    printColored("Private key:", key.private_bytes(format=PrivateFormat.TraditionalOpenSSL,
                                                   encoding=Encoding.DER, encryption_algorithm=NoEncryption()).hex())

printHeader("\n---------------1) Generation of public-private key pairs.---------------", color="Red")

printHeader(" Q 1.a")
K_A = generate_rsa()
printColored("Public key:", K_A["public"])
printColored("Private key:", K_A["private"])

printHeader(" Q 1.b")
[K_B, K_C] = generate_ECDH()
printHeader("*** ECDH Key Pair  KB *** ")
printECDH(K_B)
printHeader("*** ECDH Key Pair  KC *** ")
printECDH(K_C)